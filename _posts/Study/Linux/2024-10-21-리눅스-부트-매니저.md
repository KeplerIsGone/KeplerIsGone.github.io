---
layout: post
title: "[Linux] 리눅스 부트 매니저"
date: 2024-10-21
category: Study
tags: Linux
---

# 개요

이 노트는 부팅 과정, 부트 매니저, 커널 초기화, 시스템 관리자(systemd), 그리고 리눅스의 로그인과 로그아웃 과정에 대해 다룬다. 부팅의 각 단계, 부트로더의 역할, 대표적인 부트로더인 GRUB의 특징과 사용법, 커널 초기화 후 systemd가 담당하는 시스템 관리, 그리고 로그인과 로그아웃의 절차를 구체적으로 설명한다.

---

## 부팅(Booting)의 정의

부팅이란 전원을 켜고 나서 로그인 프롬프트가 나타날 때까지의 과정을 의미한다. 이 과정은 **PC Booting**과 **Linux Booting**으로 나눌 수 있으며, 주요 단계는 다음과 같다:

- BIOS
- MBR (Master Boot Record)
- Boot Loader (부트로더)
- Kernel (커널)
- systemd
- login shell

### 부팅의 과정

**BIOS**

BIOS(Basic Input/Output System)는 컴퓨터가 전원을 켠 직후 제일 먼저 동작하는 소프트웨어로, ROM에 저장되어 있다. BIOS는 하드웨어의 상태를 확인하고, 하드디스크의 0번 섹터에서 **MBR**을 로딩하는데, MBR에는 부팅에 필요한 boot code와 partition table이 저장되어 있다.

**MBR (Master Boot Record)**

MBR은 하드디스크의 첫 번째 섹터에 위치하며, 부트로더를 실행하기 위한 정보를 가지고 있다. 부팅이 시작될 때 BIOS가 MBR을 읽고, 그 안에 있는 부트로더를 실행한다.

**부트로더 (Boot Loader)**

부트로더는 **bootstrap loader**의 약자로, 디스크나 플래시에 있는 운영체제를 주기억장치에 올리는 역할을 한다. OS 시동 전에 동작하며 커널을 로드하고, 운영체제를 실행시킨다. 일반적으로 **MBR**에 위치하며, 이를 통해 운영체제를 선택할 수 있다. 임베디드 시스템에서는 부트로더가 OS 로더와 BIOS 역할을 동시에 수행하기도 한다.

- **LILO**와 **GRUB**는 x86 아키텍처에서 자주 사용되는 부트로더다. **LILO**는 리눅스 전용이어서 현재는 **GRUB**이 더 널리 사용된다.
- **부트 매니저**는 부트로더와 같은 의미로 사용되며, 운영체제 시동 전에 실행된다.

? **mrb는 부트로더와 독립적인 것인가?**

**답변**: MBR은 부트로더와 밀접하게 연관되어 있지만, 자체적으로 부트로더의 일부는 아니다. MBR은 부트로더를 실행하는 첫 단계로, 운영체제를 선택할 수 있는 환경을 제공하는 역할을 한다. 부트로더는 그 위에서 운영체제를 로드하는 기능을 수행한다.

## GRUB (Grand Unified Bootloader)

**GRUB의 특징**

GRUB은 **LILO**의 단점을 보완한 부트로더로, 설정 및 사용이 간편하다. 주요 기능은 다음과 같다:

- 부트 정보를 쉽게 변경할 수 있다.
- 멀티부팅이 가능하다.
- 대화형 설정이 가능하며, 파일 시스템을 자동으로 인식한다.

? **멀티부팅이란?**

**답변**: 멀티부팅이란 하나의 시스템에서 여러 운영체제를 선택해 부팅할 수 있는 기능을 의미한다. 예를 들어, 하나의 컴퓨터에 Linux와 Windows를 설치한 후, 부팅할 때 어떤 운영체제를 실행할지 선택할 수 있는 것이다.

? **GRUB이 MBR에 설치되지 않아도 된다는 뜻은 무엇인가?**

**답변**: GRUB은 MBR뿐만 아니라 특정 파티션에 설치될 수 있다. 즉, 부트로더를 MBR에 설치하지 않고도, 운영체제가 설치된 파티션에 GRUB을 설치하여 사용할 수 있다는 의미다.

**GRUB Legacy vs GRUB2**

GRUB은 두 가지 버전으로 나뉜다: GRUB Legacy와 GRUB2. 각각의 차이점은 다음과 같다:

| 항목             | GRUB Legacy           | GRUB2                    |
| ---------------- | --------------------- | ------------------------ |
| 설정 파일        | `/boot/grub/menu.lst` | `/boot/grub2/grub.cfg`   |
| 파티션 번호 체계 | 0부터 시작            | 1부터 시작               |
| root 지정 방식   | `root(hd0,0)`         | `set root=(hd0, msdos1)` |
| 커널 이미지 지정 | `kernel=`             | `linux=`                 |

## 커널 초기화

**커널 초기화 과정**

커널은 부팅 후 장치를 검사하고, 각종 프로세스와 스레드를 생성한다. 이때 생성되는 커널 프로세스는 메모리 관리와 같은 역할을 수행하며, 대괄호로 표시되고 낮은 PID 번호로 구분된다.  
커널이 필요한 프로세스를 생성하면 커널의 역할은 끝나고, **systemd**가 실행된다.

## systemd와 init 시스템

**systemd의 개요**

systemd는 기존의 **init 스크립트**를 대체한 시스템 관리 도구로, 부팅 시 필요한 서비스 데몬을 시작하고 프로세스를 관리한다. systemd는 항상 **PID 1번**으로 실행되며, 시스템의 상태를 유지하는 중요한 역할을 한다.  
**init**은 더 이상 사용되지 않지만, 호환성을 위해 파일이 남아있다. systemd를 이해하기 위해 먼저 init의 동작 방식을 알아본다.

**init 시스템과 런레벨 (Runlevel)**

init은 시스템 상태를 **7개의 런레벨(Runlevel)**로 나누고, 각 상태에 맞는 스크립트를 실행한다. 각 런레벨은 `/etc/inittab` 파일에서 설정되며, 해당 런레벨에 맞는 스크립트는 `/etc/rc.d/init.d/`에 위치한다. 런레벨의 주요 기능은 다음과 같다:

| 런레벨 | 설명                                   |
| ------ | -------------------------------------- |
| 0      | 시스템 종료                            |
| 1, S   | 단일 사용자 모드 (시스템 점검 및 복구) |
| 2      | 다중 사용자 모드 (NFS 미사용)          |
| 3      | 다중 사용자 모드 (NFS 사용)            |
| 4      | 사용하지 않음 (예비 번호)              |
| 5      | X11 그래픽 모드                        |
| 6      | 시스템 재부팅                          |

? **단일 사용자 모드는 시스템 점검 및 복구에 사용하기도 하나요?**

**답변**: 네, 단일 사용자 모드는 시스템 점검 및 복구에 사용됩니다. 주로 네트워크 서비스 없이 루트 권한으로 접근하여 시스템 문제를 해결할 수 있는 안전한 환경을 제공합니다.

? **X11 상태 재부팅이란 무엇인가요?**

**답변**: X11 상태란 그래픽 사용자 인터페이스(GUI) 환경을 의미합니다. X11 상태에서 재부팅은 GUI가 포함된 모드로 시스템이 시작되는 것을 뜻합니다. 런레벨 5에서 그래픽 환경으로 부팅됩니다.

**systemd에서의 런레벨 대응**

systemd는 기존 init의 런레벨을 새로운 **target** 개념으로 대체한다. 이로 인해 systemd는 더 유연한 시스템 관리가 가능해졌다. 특히 다음과 같은 장점이 있다:

- **inetd와의 호환성** 유지
- **shell과 독립적**으로 동작
- **mnt, fsck 제어 가능**
- **스냅샷** 기능을 통한 상태 유지
- **SELinux와의 통합** 가능
- 서비스에 **시그널 전달 가능**
- 사용자 세션을 **안전하게 종료**할 수 있음

**systemd의 유닛(Unit)**

systemd에서 각종 시스템 서비스는 **유닛(Unit)**으로 관리된다. 유닛은 `<service>.<unit>`의 형태로 사용되며, 대표적인 유닛 유형은 다음과 같다:

- **service**: 서비스 관리 유닛
- **target**: 런레벨과 유사한 시스템 상태를 정의
- **automount**: 자동 마운트 유닛
- **device**: 디바이스 관리 유닛
- **mount**: 파일 시스템 마운트 유닛
- **path**: 파일 또는 디렉토리 경로를 관리하는 유닛
- **scope**: 외부 프로세스를 관리하는 유닛
- **slice**: 시스템 리소스 분할 유닛
- **socket**: 소켓 기반 활성화 유닛
- **swap**: 스왑 공간 관리 유닛
- **timer**: 타이머 관리 유닛

**systemctl 명령어**

systemctl 명령어를 통해 systemd 유닛을 제어하고 관리할 수 있다. 주요

명령어는 다음과 같다:

- `-a`: 모든 유닛 표시
- `status <unit>`: 특정 유닛의 상태를 확인
- `stop <unit>`: 유닛 정지
- `start <unit>`: 유닛 시작
- `restart <unit>`: 유닛 재시작
- `get-default`: 기본 타겟 확인
- `set-default <target>`: 기본 타겟 설정
- `isolate <target>`: 특정 타겟으로 시스템 전환

**런레벨과 target 매핑**

systemd의 런레벨은 `/usr/lib/systemd/system/` 경로에서 확인할 수 있으며, `runlevelN.target`으로 등록된 링크를 통해 각 런레벨에 대응하는 target 정보를 얻을 수 있다.

## 리눅스 로그인과 로그아웃

**로그인 과정**

로그인 시 시스템은 사용자의 **패스워드를 `/etc/passwd` 파일**에 있는 정보와 비교한다. 로그인 절차는 다음과 같은 설정 파일을 거쳐 진행된다:

- `/etc/issue`: 텍스트 콘솔에서 로그인 전에 표시되는 시스템 메시지
- `/etc/issue.net`: 네트워크 로그인 시 표시되는 메시지
- `/etc/motd`: 로그인 후 시스템 공지 사항을 표시하는 메시지

? **각 파일의 특징을 비교해 주세요.**

**답변**:

- **/etc/issue**: 로컬 콘솔에 로그인하기 전에 표시되는 텍스트 메시지로, 주로 시스템 상태나 경고 메시지를 제공한다.
- **/etc/issue.net**: 네트워크를 통한 원격 로그인(Telnet, SSH) 시 나타나는 메시지이다.
- **/etc/motd**: 성공적으로 로그인한 후 나타나는 메시지로, 관리자가 설정한 시스템 공지 사항을 보여준다.

**로그아웃 과정**

로그아웃은 `logout`, `exit` 명령어를 사용하거나, **Ctrl+D**를 입력하여 수행된다. 또한, `/etc/profile` 파일에서 설정된 **TMOUT 변수**를 수정하여, 일정 시간 동안 사용자가 활동하지 않으면 자동으로 강제 로그아웃되도록 설정할 수 있다.
